<!DOCTYPE html>
<html lang="es">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Diablo Clone - Phaser 3</title>
    <!-- Cargar Phaser 3 -->
    <script src="https://cdn.jsdelivr.net/npm/phaser@3.60.0/dist/phaser.min.js"></script>
    <style>
        /* --- ESTILOS GENERALES Y HUD --- */
        body {
            margin: 0;
            background-color: #000;
            height: 100vh;
            overflow: hidden;
            font-family: 'Cinzel', 'Courier New', serif; /* Fuente estilo clásico */
            user-select: none;
            color: #d4af37; /* Dorado Diablo */
        }

        #game-wrapper {
            position: relative;
            width: 100%;
            height: 100%;
            display: flex;
            justify-content: center;
            align-items: center;
        }

        /* --- HUD INFERIOR (Estilo Diablo) --- */
        #hud {
            position: absolute;
            bottom: 0;
            width: 100%;
            height: 100px;
            background: linear-gradient(to top, #1a1a1a, #000);
            border-top: 2px solid #444;
            display: flex;
            justify-content: center;
            align-items: center;
            pointer-events: none; /* Dejar pasar clics al juego si no es botón */
        }

        /* Orbes de Vida y Maná */
        .orb {
            width: 90px;
            height: 90px;
            border-radius: 50%;
            background: #222;
            border: 3px solid #555;
            position: absolute;
            bottom: 10px;
            overflow: hidden;
            box-shadow: inset 0 0 20px #000;
        }
        .orb-fill {
            width: 100%;
            position: absolute;
            bottom: 0;
            transition: height 0.2s;
        }
        .orb-text {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            color: #fff;
            font-size: 14px;
            text-shadow: 1px 1px 2px #000;
            z-index: 2;
        }

        #health-orb { left: 20px; }
        #health-fill { background: radial-gradient(circle, #ff4444, #990000); height: 100%; }
        
        #mana-orb { right: 20px; }
        #mana-fill { background: radial-gradient(circle, #4444ff, #000099); height: 100%; }

        /* Barra de Habilidades / Info */
        #skill-bar {
            display: flex;
            gap: 10px;
            pointer-events: auto;
        }
        .skill-slot {
            width: 50px;
            height: 50px;
            background: #333;
            border: 2px solid #666;
            display: flex;
            justify-content: center;
            align-items: center;
            font-size: 10px;
            color: #888;
            cursor: pointer;
        }
        .skill-slot:hover { border-color: #d4af37; }

        /* --- VENTANAS (Inventario / Tienda) --- */
        .window {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            background: rgba(10, 10, 10, 0.95);
            border: 2px solid #d4af37;
            padding: 20px;
            display: none; /* Oculto por defecto */
            flex-direction: column;
            color: #ccc;
            min-width: 300px;
            z-index: 100;
        }
        .window h2 { margin-top: 0; color: #d4af37; text-align: center; border-bottom: 1px solid #444; padding-bottom: 10px;}
        
        /* Rejilla de Inventario */
        #inventory-grid {
            display: grid;
            grid-template-columns: repeat(5, 50px);
            gap: 5px;
            margin-top: 10px;
        }
        .inv-slot {
            width: 50px;
            height: 50px;
            background: #222;
            border: 1px solid #444;
            display: flex;
            justify-content: center;
            align-items: center;
            cursor: pointer;
            position: relative;
        }
        .inv-slot:hover { border-color: #fff; }
        .inv-slot img { width: 32px; height: 32px; }
        .inv-slot.equipped {
            border-color: #d4af37;
            box-shadow: 0 0 5px #d4af37;
        }

        /* Tienda */
        .shop-item {
            display: flex;
            justify-content: space-between;
            padding: 10px;
            border-bottom: 1px solid #333;
            cursor: pointer;
        }
        .shop-item:hover { background: #222; }
        .btn-buy {
            background: #550000;
            color: #fff;
            border: 1px solid #d4af37;
            padding: 2px 8px;
            cursor: pointer;
        }

        /* Tooltip */
        #tooltip {
            position: absolute;
            background: #111;
            border: 1px solid #888;
            padding: 5px;
            color: #fff;
            font-size: 12px;
            pointer-events: none;
            display: none;
            z-index: 200;
        }
    </style>
</head>
<body>

<div id="game-wrapper">
    <!-- HUD -->
    <div id="hud">
        <!-- Orbe Vida -->
        <div id="health-orb" class="orb">
            <div id="health-fill" class="orb-fill"></div>
            <div class="orb-text" id="hp-text">100</div>
        </div>

        <!-- Barra Central -->
        <div style="text-align: center;">
            <div style="color: #d4af37; margin-bottom: 5px;">HÉROE - NIVEL 1</div>
            <div id="skill-bar">
                <div class="skill-slot">ATK</div>
                <div class="skill-slot">POT</div>
                <div class="skill-slot">INV (I)</div>
            </div>
            <div style="margin-top:5px; font-size: 12px;">Oro: <span id="gold-display">0</span></div>
            <div style="font-size: 10px; color: #aaa;">ATK: <span id="atk-display">10</span></div>
        </div>

        <!-- Orbe Maná -->
        <div id="mana-orb" class="orb">
            <div id="mana-fill" class="orb-fill"></div>
            <div class="orb-text" id="mana-text">50</div>
        </div>
    </div>

    <!-- Ventana Inventario -->
    <div id="inventory-window" class="window">
        <h2>INVENTARIO</h2>
        <div id="inventory-grid"></div>
        <p style="font-size: 10px; text-align: center; color: #666;">Clic derecho para equipar</p>
    </div>

    <!-- Ventana Tienda -->
    <div id="shop-window" class="window">
        <h2>MERCADER</h2>
        <div id="shop-list"></div>
        <button onclick="toggleShop()" style="margin-top: 10px; width: 100%;">Cerrar</button>
    </div>

    <!-- Tooltip -->
    <div id="tooltip"></div>
</div>

<script>
/**
 * ==========================================
 * 1. CONFIGURACIÓN PHASER
 * ==========================================
 */
// Estado global para UI
let uiState = {
    inventoryOpen: false,
    shopOpen: false,
    playerData: null // Referencia para actualizar UI
};

class MainScene extends Phaser.Scene {
    constructor() {
        super('MainScene');
    }

    preload() {
        // --- CARGA DE ASSETS (OPCIONAL) ---
        // NOTA IMPORTANTE: Si abres este archivo directamente en el navegador (file://),
        // las imágenes NO se cargarán por seguridad (CORS) y verás la pantalla negra.
        // Para usar imágenes propias, necesitas un servidor local (Live Server en VSCode, etc).
        
        // Si tienes servidor local, DESCOMENTA estas líneas y COMENTA la sección de abajo:
        /*
        this.load.spritesheet('player', 'player.png', { frameWidth: 32, frameHeight: 32 });
        this.load.image('enemy', 'enemy.png');
        this.load.image('wall', 'wall.png');
        this.load.image('floor', 'floor.png');
        this.load.image('item', 'item.png');
        this.load.image('npc', 'npc.png');
        this.load.image('door', 'door.png');
        */

        // --- GENERACIÓN DE TEXTURAS (FALLBACK) ---
        // Usamos esto por defecto para que el juego funcione sin servidor local.
        // --- GENERACIÓN DE TEXTURAS (Placeholders) ---
        // Jugador (Simulando Sprite Sheet con 2 frames para animación)
        let g = this.make.graphics({x:0, y:0, add: false});
        
        // Frame 1: Idle/Walk 1
        g.fillStyle(0x3366ff, 1);
        g.fillRect(0, 0, 32, 32);
        // Frame 2: Walk 2 (Color diferente para notar animación)
        g.fillStyle(0x2244aa, 1);
        g.fillRect(32, 0, 32, 32);
        g.generateTexture('player_sheet', 64, 32); // Textura de 64x32 (2 frames de 32x32)

        // Enemigo
        g.clear();
        g.fillStyle(0xcc0000, 1);
        g.fillRect(0, 0, 32, 32);
        g.generateTexture('enemy', 32, 32);

        // Pared
        g.clear();
        g.fillStyle(0x555555, 1);
        g.fillRect(0, 0, 40, 40);
        g.fillStyle(0x333333, 1);
        g.fillRect(0, 30, 40, 10); // Detalle 3D
        g.generateTexture('wall', 40, 40);

        // Piso
        g.clear();
        g.fillStyle(0x1a1a1a, 1);
        g.fillRect(0, 0, 40, 40);
        g.lineStyle(1, 0x222222);
        g.strokeRect(0, 0, 40, 40);
        g.generateTexture('floor', 40, 40);

        // Ítem
        g.clear();
        g.fillStyle(0xffd700, 1);
        g.fillCircle(10, 10, 8);
        g.generateTexture('item', 20, 20);

        // NPC
        g.clear();
        g.fillStyle(0x00ff00, 1);
        g.fillRect(0, 0, 32, 32);
        g.generateTexture('npc', 32, 32);

        // Puerta (Salida de nivel)
        g.clear();
        g.fillStyle(0xffffff, 1);
        g.fillRect(0, 0, 40, 40);
        g.generateTexture('door', 40, 40);
    }

    create() {
        // --- CONFIGURACIÓN DE ANIMACIONES ---
        // Detectar si usamos texturas generadas o imágenes cargadas
        if (this.textures.exists('player_sheet')) {
            // Lógica para texturas generadas
            const sheet = this.textures.get('player_sheet');
            if (!sheet.has('frame0')) sheet.add('frame0', 0, 0, 0, 32, 32);
            if (!sheet.has('frame1')) sheet.add('frame1', 0, 32, 0, 32, 32);

            this.anims.create({
                key: 'walk',
                frames: [ { key: 'player_sheet', frame: 'frame0' }, { key: 'player_sheet', frame: 'frame1' } ],
                frameRate: 8, repeat: -1
            });
            this.anims.create({ key: 'idle', frames: [ { key: 'player_sheet', frame: 'frame0' } ], frameRate: 1 });
        } else {
            // Lógica para imágenes cargadas (player.png)
            this.anims.create({
                key: 'walk',
                frames: this.anims.generateFrameNumbers('player', { start: 0, end: 1 }),
                frameRate: 8, repeat: -1
            });
            this.anims.create({ key: 'idle', frames: [ { key: 'player', frame: 0 } ], frameRate: 1 });
        }

        // Grupo estático para paredes
        this.walls = this.physics.add.staticGroup();
        this.enemies = this.physics.add.group();
        this.items = this.physics.add.group();
        this.doorGroup = this.physics.add.staticGroup(); // Grupo para la puerta

        // --- JUGADOR ---
        // Usar 'player_sheet' si existe (generado), sino 'player' (externo)
        const playerTexture = this.textures.exists('player_sheet') ? 'player_sheet' : 'player';
        const startFrame = this.textures.exists('player_sheet') ? 'frame0' : 0;
        
        this.player = this.physics.add.sprite(300, 300, playerTexture, startFrame);
        this.player.setCollideWorldBounds(true);
        
        // Datos del jugador (RPG)
        this.player.dataValues = {
            hp: 100, maxHp: 100,
            mana: 50, maxMana: 50,
            gold: 0,
            level: 1, // Nivel actual de mazmorra
            inventory: [],
            equipment: { weapon: null, armor: null }, // Equipo actual
            baseAttack: 10,
            baseDefense: 0
        };
        uiState.playerData = this.player.dataValues; // Enlace para UI

        // Colisión con paredes
        this.physics.add.collider(this.player, this.walls);
        this.physics.add.collider(this.enemies, this.walls);
        this.physics.add.collider(this.enemies, this.enemies);
        
        // Colisión con puerta
        this.physics.add.overlap(this.player, this.doorGroup, this.nextLevel, null, this);
        // Recoger ítems
        this.physics.add.overlap(this.player, this.items, this.pickupItem, null, this);

        // --- CÁMARA ---
        this.cameras.main.startFollow(this.player, true, 0.1, 0.1);
        this.cameras.main.setZoom(1.2);

        // --- MINIMAPA ---
        this.minimap = this.cameras.add(630, 20, 150, 150).setZoom(0.15).setName('mini');
        this.minimap.setBackgroundColor(0x000000);
        this.minimap.startFollow(this.player);
        this.minimap.setAlpha(0.8);
        // Borde simple para minimapa (Gráfico UI)
        let minimapBorder = this.add.graphics().setScrollFactor(0);
        minimapBorder.lineStyle(2, 0x444444);
        minimapBorder.strokeRect(630, 20, 150, 150);

        // --- NPC ---
        this.npc = this.physics.add.staticSprite(400, 400, 'npc');
        let npcText = this.add.text(380, 370, "Vendedor", { fontSize: '12px', color: '#fff' });

        // --- ILUMINACIÓN (FOG OF WAR) ---
        // Usamos una RenderTexture oscura que cubre la pantalla
        this.lightLayer = this.add.renderTexture(0, 0, 1600, 1600);
        this.lightLayer.setDepth(100); // Encima de todo
        this.lightLayer.fill(0x000000, 0.9); // Oscuridad casi total
        
        // El minimapa no debe ver la capa de oscuridad
        this.minimap.ignore(this.lightLayer);

        // --- CONTROLES ---
        this.cursors = this.input.keyboard.addKeys({
            up: Phaser.Input.Keyboard.KeyCodes.W,
            down: Phaser.Input.Keyboard.KeyCodes.S,
            left: Phaser.Input.Keyboard.KeyCodes.A,
            right: Phaser.Input.Keyboard.KeyCodes.D,
            interact: Phaser.Input.Keyboard.KeyCodes.E,
            inv: Phaser.Input.Keyboard.KeyCodes.I
        });

        this.input.on('pointerdown', (pointer) => {
            if (!uiState.shopOpen && !uiState.inventoryOpen) this.attack(pointer);
        });

        // Teclas UI
        this.input.keyboard.on('keydown-E', () => this.interact());
        this.input.keyboard.on('keydown-I', () => toggleInventory());

        // INICIAR NIVEL 1
        this.initLevel(1);

        // Actualizar HUD inicial
        updateHUD();
    }

    // ==========================================
    // SISTEMA DE NIVELES Y MAPA
    // ==========================================
    initLevel(level) {
        this.player.dataValues.level = level;
        
        // Limpiar nivel anterior
        this.walls.clear(true, true);
        this.enemies.clear(true, true);
        this.items.clear(true, true);
        this.doorGroup.clear(true, true);
        this.doorSpawned = false;

        // Configuración de mapa
        const TILE_SIZE = 40;
        const MAP_WIDTH = 40 + (level * 5); // Mapa crece con nivel
        const MAP_HEIGHT = 40 + (level * 5);
        
        // Ajustar límites del mundo y cámara (SOLUCIÓN ÁREA NEGRA)
        this.physics.world.setBounds(0, 0, MAP_WIDTH * TILE_SIZE, MAP_HEIGHT * TILE_SIZE);
        this.cameras.main.setBounds(0, 0, MAP_WIDTH * TILE_SIZE, MAP_HEIGHT * TILE_SIZE);
        
        // Redimensionar capa de luz
        this.lightLayer.resize(MAP_WIDTH * TILE_SIZE, MAP_HEIGHT * TILE_SIZE);

        // Generar paredes y piso
        for (let y = 0; y < MAP_HEIGHT; y++) {
            for (let x = 0; x < MAP_WIDTH; x++) {
                let posX = x * TILE_SIZE + TILE_SIZE/2;
                let posY = y * TILE_SIZE + TILE_SIZE/2;

                // Bordes o aleatorio
                let isWall = (x === 0 || x === MAP_WIDTH - 1 || y === 0 || y === MAP_HEIGHT - 1 || Math.random() < 0.1);
                
                // Zona segura inicial (centro aprox)
                if (x > 4 && x < 10 && y > 4 && y < 10) isWall = false;

                if (isWall) {
                    this.walls.create(posX, posY, 'wall');
                } else {
                    this.add.image(posX, posY, 'floor');
                }
            }
        }

        // Reposicionar jugador
        this.player.setPosition(300, 300);

        // Spawnear Enemigos (Dificultad progresiva)
        const enemyCount = 5 + (level * 3);
        for(let i=0; i<enemyCount; i++) {
            let x = Phaser.Math.Between(TILE_SIZE, MAP_WIDTH * TILE_SIZE - TILE_SIZE);
            let y = Phaser.Math.Between(TILE_SIZE, MAP_HEIGHT * TILE_SIZE - TILE_SIZE);
            
            // Evitar spawnear muy cerca del jugador
            if (Phaser.Math.Distance.Between(x, y, this.player.x, this.player.y) > 300) {
                let enemy = this.enemies.create(x, y, 'enemy');
                enemy.hp = 30 + (level * 10); // Más vida por nivel
                enemy.maxHp = enemy.hp;
                enemy.damage = 5 + level; // Más daño
                enemy.setCollideWorldBounds(true);
                enemy.setBounce(1);
            }
        }
        
        console.log(`Nivel ${level} iniciado. Enemigos: ${enemyCount}`);
    }

    spawnDoor() {
        if (this.doorSpawned) return;
        this.doorSpawned = true;
        
        // Spawnear puerta lejos del jugador
        let x = Phaser.Math.Between(200, this.physics.world.bounds.width - 200);
        let y = Phaser.Math.Between(200, this.physics.world.bounds.height - 200);
        
        let door = this.doorGroup.create(x, y, 'door');
        
        // Efecto visual para avisar al jugador
        this.tweens.add({
            targets: door,
            alpha: 0.5,
            yoyo: true,
            repeat: -1,
            duration: 500
        });
        
        // Mensaje flotante
        let txt = this.add.text(x - 20, y - 40, "SALIDA", { fontSize: '16px', color: '#fff', backgroundColor: '#000' });
        this.time.delayedCall(5000, () => txt.destroy());
        
        alert("¡Nivel completado! Busca la puerta blanca para avanzar.");
    }

    nextLevel() {
        let nextLvl = this.player.dataValues.level + 1;
        this.initLevel(nextLvl);
    }

    update() {
        if (uiState.shopOpen) {
            this.player.body.setVelocity(0);
            return;
        }

        // Movimiento
        const speed = 200;
        this.player.body.setVelocity(0);

        if (this.cursors.left.isDown) this.player.body.setVelocityX(-speed);
        else if (this.cursors.right.isDown) this.player.body.setVelocityX(speed);

        if (this.cursors.up.isDown) this.player.body.setVelocityY(-speed);
        else if (this.cursors.down.isDown) this.player.body.setVelocityY(speed);

        this.player.body.velocity.normalize().scale(speed);

        // Animaciones del Jugador
        if (this.player.body.velocity.length() > 0) {
            this.player.play('walk', true);
        } else {
            this.player.play('idle', true);
        }

        // IA Enemigos
        this.enemies.getChildren().forEach(enemy => {
            let dist = Phaser.Math.Distance.Between(enemy.x, enemy.y, this.player.x, this.player.y);
            if (dist < 300 && dist > 30) {
                this.physics.moveToObject(enemy, this.player, 80);
            } else {
                enemy.body.setVelocity(0);
            }

            // Daño al jugador
            if (dist < 30) {
                // Defensa reduce daño
                let def = getPlayerStats(this.player.dataValues).def;
                let dmg = Math.max(0.1, (enemy.damage || 5) * 0.02 - (def * 0.01)); // Fórmula simple
                
                this.player.dataValues.hp -= dmg;
                updateHUD();
                if(this.player.dataValues.hp <= 0) {
                    this.scene.restart();
                    alert("Has muerto");
                }
            }
        });

        // Chequear condición de victoria del nivel
        if (this.enemies.countActive() === 0 && !this.doorSpawned) {
            this.spawnDoor();
        }

        // Iluminación (Fog of War)
        // Rellenar de negro y borrar círculo en el jugador
        this.lightLayer.fill(0x000000, 0.9);
        this.lightLayer.erase('item', this.player.x, this.player.y); // Usamos la textura 'item' (círculo) como pincel de borrado
        // Para un círculo más grande, podríamos usar un gráfico invisible o una textura dedicada
        // Truco rápido: borrar varias veces o usar una textura de luz más grande.
        // Aquí usaremos un gráfico máscara simple para mejor efecto visual en Phaser
        // (Reemplazando la lógica de erase simple por una máscara visual si se desea, pero erase es funcional)
        
        // Mejor enfoque para "Luz":
        // Crear un círculo de "luz" y usarlo para borrar la oscuridad
        let light = this.make.graphics({ x: this.player.x, y: this.player.y, add: false });
        light.fillStyle(0xffffff);
        light.fillCircle(0, 0, 150);
        this.lightLayer.erase(light, this.player.x, this.player.y);
    }

    attack(pointer) {
        // Convertir coordenadas de pantalla a mundo
        let worldPoint = this.cameras.main.getWorldPoint(pointer.x, pointer.y);
        
        // Efecto visual
        let graphics = this.add.graphics();
        graphics.lineStyle(2, 0xffffff);
        graphics.lineBetween(this.player.x, this.player.y, worldPoint.x, worldPoint.y);
        this.tweens.add({
            targets: graphics,
            alpha: 0,
            duration: 200,
            onComplete: () => graphics.destroy()
        });

        // Calcular daño total
        const stats = getPlayerStats(this.player.dataValues);
        const damage = stats.atk;

        // Lógica de daño
        this.enemies.getChildren().forEach(enemy => {
            if (Phaser.Math.Distance.Between(worldPoint.x, worldPoint.y, enemy.x, enemy.y) < 50) {
                enemy.hp -= damage;
                // Feedback visual enemigo
                this.tweens.add({
                    targets: enemy,
                    alpha: 0.5,
                    yoyo: true,
                    duration: 50
                });

                if (enemy.hp <= 0) {
                    this.dropLoot(enemy.x, enemy.y);
                    enemy.destroy();
                }
            }
        });

        // Gasto maná
        if(this.player.dataValues.mana > 0) {
            this.player.dataValues.mana -= 2;
            updateHUD();
        }
    }

    dropLoot(x, y) {
        // Probabilidad de drop
        let rand = Math.random();
        let itemData = null;
        let color = 0xffd700; // Oro por defecto

        if (rand < 0.4) {
            // 40% Oro
            itemData = { name: "Monedas de Oro", type: "gold", value: Phaser.Math.Between(10, 50) };
        } else if (rand < 0.6) {
            // 20% Poción
            itemData = { name: "Poción Menor", type: "potion", value: 10 };
            color = 0xff0000;
        } else if (rand < 0.7) {
            // 10% Arma
            itemData = { name: "Espada de Hierro", type: "weapon", attackBonus: 5, value: 50 };
            color = 0xaaaaaa;
        } else if (rand < 0.8) {
            // 10% Armadura
            itemData = { name: "Peto de Cuero", type: "armor", defenseBonus: 3, value: 40 };
            color = 0x8b4513;
        }

        if (itemData) {
            let item = this.items.create(x, y, 'item');
            item.setTint(color);
            item.dataValues = itemData;
        }
    }

    pickupItem(player, item) {
        const data = item.dataValues;
        
        if (data.type === 'gold') {
            // Acumular oro directamente
            player.dataValues.gold += data.value;
            // Texto flotante
            let txt = this.add.text(player.x, player.y - 20, `+${data.value} Oro`, { fontSize: '12px', color: '#ffd700' });
            this.tweens.add({ targets: txt, y: player.y - 50, alpha: 0, duration: 1000, onComplete: () => txt.destroy() });
        } else {
            // Al inventario
            player.dataValues.inventory.push(data);
        }
        
        item.destroy();
        updateHUD();
        renderInventory();
    }

    interact() {
        if (Phaser.Math.Distance.Between(this.player.x, this.player.y, this.npc.x, this.npc.y) < 80) {
            toggleShop();
        }
    }
}

// Configuración Phaser
const config = {
    type: Phaser.AUTO,
    width: 800,
    height: 600,
    parent: 'game-wrapper',
    backgroundColor: '#000',
    physics: {
        default: 'arcade',
        arcade: {
            gravity: { y: 0 },
            debug: false
        }
    },
    scene: MainScene
};

const game = new Phaser.Game(config);

/**
 * ==========================================
 * 2. SISTEMA DE UI (HTML/DOM)
 * ==========================================
 */
function getPlayerStats(p) {
    let atk = p.baseAttack;
    let def = p.baseDefense;
    if (p.equipment.weapon) atk += p.equipment.weapon.attackBonus || 0;
    if (p.equipment.armor) def += p.equipment.armor.defenseBonus || 0;
    return { atk, def };
}

function updateHUD() {
    if (!uiState.playerData) return;
    const p = uiState.playerData;
    const stats = getPlayerStats(p);

    // Actualizar textos
    document.getElementById('hp-text').innerText = Math.floor(p.hp);
    document.getElementById('mana-text').innerText = Math.floor(p.mana);
    document.getElementById('gold-display').innerText = p.gold;
    document.getElementById('atk-display').innerText = stats.atk + " (Def: " + stats.def + ")";

    // Actualizar altura de los orbes (CSS height)
    let hpPercent = (p.hp / p.maxHp) * 100;
    let manaPercent = (p.mana / p.maxMana) * 100;
    
    document.getElementById('health-fill').style.height = hpPercent + '%';
    document.getElementById('mana-fill').style.height = manaPercent + '%';
}

function toggleInventory() {
    if (!uiState.playerData) return;
    uiState.inventoryOpen = !uiState.inventoryOpen;
    let win = document.getElementById('inventory-window');
    win.style.display = uiState.inventoryOpen ? 'flex' : 'none';
    if(uiState.inventoryOpen) renderInventory();
}

function renderInventory() {
    if (!uiState.playerData) return;
    let grid = document.getElementById('inventory-grid');
    grid.innerHTML = '';
    
    const p = uiState.playerData;

    uiState.playerData.inventory.forEach((item, index) => {
        let slot = document.createElement('div');
        slot.className = 'inv-slot';
        slot.innerText = item.name.substring(0, 2); // Icono texto simple
        
        // Marcar si está equipado
        if (p.equipment.weapon === item || p.equipment.armor === item) {
            slot.classList.add('equipped');
            slot.innerText += " (E)";
        }

        // Tooltip
        let tooltipText = `${item.name}\nTipo: ${item.type}`;
        if (item.attackBonus) tooltipText += `\nATK: +${item.attackBonus}`;
        if (item.defenseBonus) tooltipText += `\nDEF: +${item.defenseBonus}`;
        
        slot.onmouseover = (e) => showTooltip(e, tooltipText);
        slot.onmouseout = hideTooltip;
        
        // Equipar / Usar
        slot.oncontextmenu = (e) => {
            e.preventDefault();
            useItem(index);
        };

        grid.appendChild(slot);
    });
}

function useItem(index) {
    if (!uiState.playerData) return;
    let item = uiState.playerData.inventory[index];
    
    if (item.type === 'potion') {
        uiState.playerData.hp = Math.min(uiState.playerData.hp + 20, uiState.playerData.maxHp);
        uiState.playerData.inventory.splice(index, 1);
    } else if (item.type === 'weapon') {
        // Equipar arma (toggle)
        if (uiState.playerData.equipment.weapon === item) {
            uiState.playerData.equipment.weapon = null; // Desequipar
        } else {
            uiState.playerData.equipment.weapon = item;
        }
    } else if (item.type === 'armor') {
        // Equipar armadura
        if (uiState.playerData.equipment.armor === item) {
            uiState.playerData.equipment.armor = null;
        } else {
            uiState.playerData.equipment.armor = item;
        }
    }
    
    updateHUD();
    renderInventory();
}

function toggleShop() {
    uiState.shopOpen = !uiState.shopOpen;
    let win = document.getElementById('shop-window');
    win.style.display = uiState.shopOpen ? 'flex' : 'none';
    
    if (uiState.shopOpen) {
        let list = document.getElementById('shop-list');
        list.innerHTML = '';
        let shopItems = [
            { name: "Espada Larga", price: 50, type: "weapon", attackBonus: 10 },
            { name: "Poción Salud", price: 10, type: "potion" },
            { name: "Armadura Cuero", price: 100, type: "armor", defenseBonus: 5 },
            { name: "Hacha de Guerra", price: 150, type: "weapon", attackBonus: 20 }
        ];

        shopItems.forEach(item => {
            let div = document.createElement('div');
            div.className = 'shop-item';
            // Pasar objeto completo como string JSON es arriesgado en onclick, mejor usar índice o simplificar
            // Para este ejemplo simple, pasamos parámetros clave
            div.innerHTML = `<span>${item.name} (${item.price}g)</span> <button class="btn-buy" onclick="buyItem('${item.name}', ${item.price}, '${item.type}', ${item.attackBonus||0}, ${item.defenseBonus||0})">Comprar</button>`;
            list.appendChild(div);
        });
    }
}

window.buyItem = function(name, price, type, atk, def) {
    if (!uiState.playerData) return;
    if (uiState.playerData.gold >= price) {
        uiState.playerData.gold -= price;
        
        let newItem = { name: name, type: type, value: Math.floor(price/2) };
        if (atk > 0) newItem.attackBonus = atk;
        if (def > 0) newItem.defenseBonus = def;
        
        uiState.playerData.inventory.push(newItem);
        updateHUD();
        alert("Comprado: " + name);
    } else {
        alert("No tienes suficiente oro.");
    }
};

// Tooltip Logic
function showTooltip(e, text) {
    let tt = document.getElementById('tooltip');
    tt.style.display = 'block';
    tt.innerText = text;
    tt.style.left = e.pageX + 10 + 'px';
    tt.style.top = e.pageY + 10 + 'px';
}
function hideTooltip() {
    document.getElementById('tooltip').style.display = 'none';
}

</script>
</body>
</html>